# Thread pool

### Base idea
При старте потока JVM, по умолчанию, выделяет 1Mb памяти для стека.
Для изменения размера стека потока можно использовать команды:
-Xss1048576 - 1Mb
-Xss1m - 1Mb
-Xss1024k - 1Mb
-XX:ThreadStackSize=1024
Минимальное значение 144K
Максимальное значение 1Gb
Зависит от системы


Исходя из этого возникают ограничения на количество создаваемых потоков.
Также, при создании большого количества потоков, возникает дополнительная нагрузка на планировщик потоков,
переключение между потоками может занять больше времени, чем выполнение самих потоков.

С целью обхода вышеупомянутых ограничений используется пул потоков. Основная идея:
1. создается ограниченное количество потоков
2. потоки сохраняются в пул
3. потоки подписываются на очередь задач
4. поток берёт задачу из очереди
5. выполнив задачу - берет следующую и т.д.

### ThreadPool

#### ThreadPoolExecutor
Базовая имплементация вышеупомянутого подхода java.util.concurrent.ThreadPoolExecutor.

*Конструктор*

ThreadPoolExecutor(corePoolSize, maxPoolSize, keepAlive, unit, workQueue)
В конструкторе задается базовое и максимальное количество потоков, которое может хранить ThreadPoolExecutor
corePoolSize и maximumPoolSize.

ThreadPoolExecutor держит запущенными столько потоков, сколько указано в corePoolSize, если нагрузка увеличивается 
и выделенных потоков недостаточно создаются дополнительные потоки, но не больше maximumPoolSize.
Неиспользуемые потоки, превышающие corePoolSize, удаляются по истечении времени указанного 
в переменной keepAliveTime и единицах измерения указанных в unit(TimeUnit). Также отдельно можно установить флаг
allowCoreThreadTimeOut, который позволяет удалять неиспользуемые потоки из количества corePoolSize.

Каждый запущенный поток должен подписаться на BlockingQueue<T>, который передается в workQueue параметре.

*Запуск*

По умолчанию пул потоков заполняется по мере вызова метода:
* .execute(<Runnable>)
* .subscribe(<Callable<T>>)
Но для ускорения процесса работы с потоками и уменьшения накладных расходов на создание потоков, можно воспользоваться методом
.prestartAllCoreThreads(). Который создаст потоки объемом соответствующим corePoolSize.

Метод subscribe возвращает объект Future<T>, который может проверить завершился ли поток isDone() и взять результат get().
Отменить выполнение потока через объект Future<T> методом .cansel(boolean)

Для завершения потоков в пуле:
* shutdown() - неблокирующий
* shutdownNow() - неблокирующий
* awaitTermination(<time>, <unit>) - ожидает завершения потоков заданное время

##### BlockingQueue

ArrayBlockingQueue - под капотом использует array, при создании требует указать размер.
LinkedBlockingQueue - под капотом список, при создании не требует указывать размер, но можно. По умолчанию размер соответствует Integer.MAX_VALUE.
SynchronousQueue - не очередь, а механизм, позволяющий передать задачу непосредственно потоку, если все потоки заняты, то задача будет отброшена.